# Main. This is where you test the solution class that was generated by calling on it.
def main():
    print("Hello World!")
    commands = ["MyQueue", "push", "push", "peek", "pop", "empty", "pop", "empty"]
    values = [[], [1], [2], [], [], [], [], []]
    driver_function(commands,values)


def driver_function(commands, values):
    queue = None
    # Iterate over the commands and values as a tuple
    for command, value in zip(commands, values):
        if command == "MyQueue":
            queue = MyQueue()
        elif command == "push":
            queue.push(value[0])
        elif command == "peek":
            print(queue.peek())
        elif command == "pop":
            print(queue.pop())
        elif command == "empty":
            print(queue.empty())

# Solution class. Copy over the information from Leetcode.
# Logic: When "push" something to a queue, it goes to the back of the queue, meaning that the first thing that's accessible in a queue
# is the thing that was pushed the earliest. FIFO. However a stack is the complete opposite, stack = LIFO.
# However with two stacks, you can keep the front of the queue in the stack labeled "front_queue"
# and on each push you need to update the "rest_of_queue" stack, moving it over to the front_queue stack and then throwing in the pushed 
# value to the bottom of that "rest_of_queue" stack. Then, put back the front value back in the front stack.
# Thus ensuring the FIFO structure, by basically making the push method reorder the stacks everytime. O(N)
# but makes the pop () method easy, at O(1), and then just readding whatevers on top of the rest_of_queue list. 
class MyQueue:
    front_queue = []
    rest_of_queue = []
    def __init__(self):
        self.front_queue = []
        self.rest_of_queue = []

    def push(self, x: int) -> None:
        if (self.empty() == False):
            front = self.front_queue.pop()
            
            # Put everything into front_queue
            while (len(self.rest_of_queue) > 0):
                self.front_queue.append(self.rest_of_queue.pop())
            
            # Put the pushed val into back of queue
            self.rest_of_queue.append(x)
            
            # Put everything back into the rest_of_queue
            while (len(self.front_queue) > 0):
                self.rest_of_queue.append(self.front_queue.pop())
            
            # Add the original front of the queue back there
            self.front_queue.append(front)
        else:
            if (self.empty()):
                self.front_queue.append(x)
            else:
                self.rest_of_queue.append(x)
    
    def pop(self) -> int:
        val = self.front_queue.pop()
        if(len(self.rest_of_queue) > 0):
            self.front_queue.append(self.rest_of_queue.pop())
        return val

    def peek(self) -> int:
        return self.front_queue[-1]

    def empty(self) -> bool:
        return len(self.front_queue) == 0 


# If this is the file that is running "__name__ == __main__",
# run the main() function
if __name__ == "__main__":
    main()

# Problem description:
# Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).

# Implement the MyQueue class:

#     void push(int x) Pushes element x to the back of the queue.
#     int pop() Removes the element from the front of the queue and returns it.
#     int peek() Returns the element at the front of the queue.
#     boolean empty() Returns true if the queue is empty, false otherwise.

# Notes:

#     You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.
#     Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.

 

# Example 1:

# Input
# ["MyQueue", "push", "push", "peek", "pop", "empty"]
# [[], [1], [2], [], [], []]
# Output
# [null, null, null, 1, 1, false]

# Explanation
# MyQueue myQueue = new MyQueue();
# myQueue.push(1); // queue is: [1]
# myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
# myQueue.peek(); // return 1
# myQueue.pop(); // return 1, queue is [2]
# myQueue.empty(); // return false

 

# Constraints:

#     1 <= x <= 9
#     At most 100 calls will be made to push, pop, peek, and empty.
#     All the calls to pop and peek are valid.

 

# Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer.

