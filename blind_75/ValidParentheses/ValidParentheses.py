

# Main. This is where you test the solution class that was generated by calling on it.
def main():
    print("Hello World!")
    solution_obj = Solution
    input = "{{{(((({{}}))))}}}{{}}[[[]]]()"
    output = solution_obj.validParantheses(input)
    print(output)


# Solution class. Copy over the information from Leetcode.
# Logic: Go through the entire string. Store all opener
# parentheses into a stack. If you encounter a closer, check
# if that closer corresponds to the top of the stack's opener
# Aka, your closer has to correspond to the most recent opener.
# Aka, ((((({{{{{}}}}})))) looks like that and not ((({{{{)))}}}.
# Hopefully that makes sense.
# I.e: ) closes (, } closes {, ] closes [.
class Solution:
    def validParantheses(input):

        validChars = ["(", ")", "[", "]", "{", "}"]
        openersStack = []
        retVal = True
        for char in input:
            if char == validChars[0] or char == validChars[2] or char == validChars[4]:
                openersStack.append(char)
            if char == validChars[1] or char == validChars[3] or char == validChars[5]:
                if len(openersStack)  > 0:
                    previousOpener = openersStack.pop()
                    indexOfOpener = validChars.index(previousOpener)
                    indexOfCloser = validChars.index(char)
                    indDiff = indexOfCloser - indexOfOpener
                    if indDiff != 1:
                        retVal = False
                        return retVal
                else:
                    retVal = False
                    return retVal

        retVal = len(openersStack) == 0
        return retVal


# If this is the file that is running "__name__ == __main__",
# run the main() function
if __name__ == "__main__":
    main()

# Problem description:
# Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

# An input string is valid if:

# Open brackets must be closed by the same type of brackets.
# Open brackets must be closed in the correct order.
# Every close bracket has a corresponding open bracket of the same type.


# Example 1:

# Input: s = "()"
# Output: true
# Example 2:

# Input: s = "()[]{}"
# Output: true
# Example 3:

# Input: s = "(]"
# Output: false


# Constraints:

# 1 <= s.length <= 104
# s consists of parentheses only '()[]{}'.