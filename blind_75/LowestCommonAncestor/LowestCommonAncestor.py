# Main. This is where you test the solution class that was generated by calling on it.
def main():
    print("Hello World!")
    solution_obj = Solution
    # Example usage
    root_list = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]
    root = build_tree(root_list)
    print_tree(root)
    p = TreeNode(2)
    q = TreeNode(8)
    retVal = solution_obj.lowestCommonAncestor(solution_obj, root, p, q)
    print_tree(retVal)

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def print_tree(root):
    if not root:
        return

    queue = [root]

    while queue:
        node = queue.pop(0)

        if node:
            print(node.val, end=' ')
            queue.append(node.left)
            queue.append(node.right)
        else:
            print(None, end=' ')

def build_tree(root_list):
    if not root_list:
        return None

    nodes = [TreeNode(val) if val is not None else None for val in root_list]
    root = nodes[0]
    queue = [root]
    i = 1

    while queue and i < len(nodes):
        node = queue.pop(0)

        if node:
            node.left = nodes[i]
            i += 1
            queue.append(node.left)

            if i < len(nodes):
                node.right = nodes[i]
                i += 1
                queue.append(node.right)

    return root

# Logic: traverse tree, until you locate both p and q and then traverse back until 
# you find where they originally branched off. SIKE. Even better solution. Since the tree 
# is sorted already, the real solution is that at each node, check the value and see if you
# go left or right (left = less than the node, right = more than, duh.)
# In theory until you encounter the ancestor, you should never go in separate directions.
# If you go in separate directions, then that is the lowestcommonancestor. Nice.
# Okay, this is good and dandy. Firstly, you need to catch the edge case of the 
# the node itself being the common ancestor... I should have caught that.
# Secondly, to make this more memory efficient, remove all instantiated objects and variables.
# The traverser is potentially unnecessary if there is no requirement to leave the input tree
# untouched, etc etc. Solution is solid. We're getting gewd.
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        traverser = root
        while (traverser != None):
            if (traverser.val == p.val or traverser.val == q.val):
                return TreeNode(traverser.val)
            p_direction = (traverser.val > p.val)
            q_direction = (traverser.val > q.val)
            if (p_direction == q_direction):
                if (p_direction):
                    traverser = traverser.left
                else:
                    traverser = traverser.right
            else:
                traverser = TreeNode(traverser.val)
                return traverser
                
        return traverser


# If this is the file that is running "__name__ == __main__",
# run the main() function
if __name__ == "__main__":
    main()

# Problem description:

# Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.

# According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”

 

# Example 1:

# Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
# Output: 6
# Explanation: The LCA of nodes 2 and 8 is 6.

# Example 2:

# Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
# Output: 2
# Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.

# Example 3:

# Input: root = [2,1], p = 2, q = 1
# Output: 2

 

# Constraints:

#     The number of nodes in the tree is in the range [2, 105].
#     -109 <= Node.val <= 109
#     All Node.val are unique.
#     p != q
#     p and q will exist in the BST.