
from typing import Optional

# Main. This is where you test the solution class that was generated by calling on it.
def main():
    print("Hello World!")
    solution_obj = Solution
    tree = TreeNode(2, TreeNode(1), TreeNode(3))
    retVal = solution_obj.invertTree(solution_obj, tree)
    print(retVal)


class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# Solution class. Copy over the information from Leetcode.
# This entire problem has recursion written all over it.
# Example 1 from Leetcode gives a big tree and asks you to invert it all. Left = right and
# right = left for all nodes.
# Example 2 gives you a tree with 3 nodes. And then you just swap, where your returned
# value's node.left = root.right and node.right = root.left.
# Thus, the best solution is to do what you do with example 2 and then expand that
# all across the tree. Aka recursion.
# NOTE: this solution doesnt compile here, but it works on LC. I get the principles, we move.
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
       if (root == None):
            return None
       else:
            traverser = TreeNode(root.val)
            retVal = traverser
            print("recursing...")
            traverser.left = self.invertTree(root.right)
            traverser.right = self.invertTree(root.left)
            return retVal



# If this is the file that is running "__name__ == __main__",
# run the main() function
if __name__ == "__main__":
    main()

# Problem description:
# Given the root of a binary tree, invert the tree, and return its root.
# Example 1:


# Input: root = [4,2,7,1,3,6,9]
# Output: [4,7,2,9,6,3,1]
# Example 2:


# Input: root = [2,1,3]
# Output: [2,3,1]
# Example 3:

# Input: root = []
# Output: []


# Constraints:

# The number of nodes in the tree is in the range [0, 100].
# -100 <= Node.val <= 100