
# Main. This is where you test the solution class that was generated by calling on it.
from turtle import left


def main():
    print("Hello World!")
    solution_obj = Solution
    retVal = solution_obj.firstBadVersion(solution_obj, 5)
    print(retVal)


# TODO: change the name of the defined method "something" to the problem name
# TODO: Write out the solution for the problem, writing out the class and method
# TODO: ensure the return value and parameters match the problem

# Solution class. Copy over the information from Leetcode.
# Logic: we want to minimize the calls to "isBadVersion(version)" when going through a list of n numbers.
# Aka, when going through a list of n numbers (that are "sorted") we need to find our number i, as fast as possible. Aka aka: binarySearch...?
# OKAY... this one hurt. Since this isnt an array, the conditions are a bit different. The while loops is leftIndex > rightIndex (not >=)
# The left index starts at 1 and rightindex starts at n. The rest of it is standard, except in the end after the while loop you return
# the leftIndex, regardless.
class Solution:
    def firstBadVersion(self, n: int) -> int:
        leftIndex = 1
        rightIndex = n
        while (leftIndex < rightIndex):
            index = (int) ((leftIndex + rightIndex) / 2)
            moveBack = isBadVersion(index)
            if (moveBack):
                if (isBadVersion(index-1) == False):
                    return index
                rightIndex = index
            else:
                leftIndex = index + 1
        return leftIndex

def isBadVersion(n: int) -> bool:
    return n==4
            # IsBadVersion returns true if the index is more than the index we want to go to. THUS, we want to 
            # reduce the rightIndex when true, increase left when false.
            print(index)
            print(leftIndex)
            print(rightIndex)

# If this is the file that is running "__name__ == __main__",
# run the main() function
if __name__ == "__main__":
    main()

# Problem description:
# You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

# Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

# You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

 

# Example 1:

# Input: n = 5, bad = 4
# Output: 4
# Explanation:
# call isBadVersion(3) -> false
# call isBadVersion(5) -> true
# call isBadVersion(4) -> true
# Then 4 is the first bad version.

# Example 2:

# Input: n = 1, bad = 1
# Output: 1

 

# Constraints:

#     1 <= bad <= n <= 231 - 1

