# Main. This is where you test the solution class that was generated by calling on it.
def main():
    print("Hello World!")
    solution_obj = Solution
    input = [7,1,5,3,6,4]
    output = solution_obj.maxProfit(input)
    print(output)

# Logic:
# At every point while going through the array (in each iteration of the for loop), you
# set a minimum and a profit variable. this makes it so that at any point, the profit is
# always the max value. Even if there is a new minimum that can yield insane values,
# the max profit variable has been set to a specific value since the previous minimum.
# If there is a price after the new insanely low minimum that beats out the max profit,
# then only does it change. This is known as DP: Dynamic Programming.
# The most commonly associated problem type with this is Fibonacci.
# Fib(4) can be broken down into various values that add up to define the actual value of
# Fib(4). In the case of Fib(4) you're storing the values of previously solved problems
# (there are 3 permutations of Fib(1) that are used to calculate Fib(4), if you store
# Fib(1) after computing it the first time, that saves a lot of time.) In the case of
# maxProfit, you store the potential profits caused by a previously cheap price
# in the current profit variable and then update the minimum and compare that
# with all future prices until the profit exceeds. Hopefully that makes sense in a decade.
class Solution:
    def maxProfit(prices):
        min = 0
        profit = 0

        for i in range(0,len(prices)):
            price = prices[i]
            if (i == 0):
                min = price
            if price < min:
                min = price
            if (price - min > profit):
                profit = price - min

        print(min)
        print(profit)

# If this is the file that is running "__name__ == __main__",
# run the main() function
if __name__ == "__main__":
    main()

# Problem description:
# You are given an array prices where prices[i] is the price of a given stock on the ith day.

# You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.

# Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.



# Example 1:

# Input: prices = [7,1,5,3,6,4]
# Output: 5
# Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
# Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
# Example 2:

# Input: prices = [7,6,4,3,1]
# Output: 0
# Explanation: In this case, no transactions are done and the max profit = 0.


# Constraints:

# 1 <= prices.length <= 105
# 0 <= prices[i] <= 104
