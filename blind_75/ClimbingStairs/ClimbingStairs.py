from typing import List
# Main. This is where you test the solution class that was generated by calling on it.
def main():
    print("Hello World!")
    solution_obj = Solution
    retVal = solution_obj.climbStairs(solution_obj, 38)
    print(retVal)

# Bruteforce logic: wow. I cant even think of this anymore.
# Actual logic: recursion for sure. Or some sort of data storing as you move up the stairs.
# This is a dynamic programming? Because when you're up 6 stairs, you should know 
# how many unique combinations have occurred thus far. 
# Right idea, wrong execution. The issue with solution 1 is that it physically compute each
# step change first 1 + 1 + 1 + .. then 1 + 1 + 2, etc.
# ... The easiest solution is that waystoreach(n) = waystoreach(n-1) + waystoreach(n-2)
# We can follow this until we reach numbers we know, let's say:
# waystoreach(1) = 1 (1)
# waystoreach(2) = 2 (1|1, 2) 
# .... This is the brute force solution. Pure Recursion is not optimal here because
# let say you haev climbstairs(38), eventually you will encounter
# climbstairs(36) twice and that climbs down the tree multiple times, thus resulting
# in a lot of extra calls. We should memorize the cases we've seen already and then just return
# those. Aka memoization with DP.

class Solution:
    def climbStairs(self, n: int) -> int:
        def recursiveClimb(storedcalls: List[int], stepstoreach:int) -> int:
            numberofsteps = 0
            if (stepstoreach <= 1):
                return 1
            if(storedcalls[stepstoreach] != -1):
                return storedcalls[stepstoreach]
            else:
                storedcalls[stepstoreach] = recursiveClimb(storedcalls, stepstoreach-1) + recursiveClimb(storedcalls, stepstoreach-2)
            return storedcalls[stepstoreach]
        list = [-1] * (n+1)
        return recursiveClimb(list, n)

# If this is the file that is running "__name__ == __main__",
# run the main() function
if __name__ == "__main__":
    main()

# Problem description:
# You are climbing a staircase. It takes n steps to reach the top.

# Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

 

# Example 1:

# Input: n = 2
# Output: 2
# Explanation: There are two ways to climb to the top.
# 1. 1 step + 1 step
# 2. 2 steps

# Example 2:

# Input: n = 3
# Output: 3
# Explanation: There are three ways to climb to the top.
# 1. 1 step + 1 step + 1 step
# 2. 1 step + 2 steps
# 3. 2 steps + 1 step

 

# Constraints:

#     1 <= n <= 45